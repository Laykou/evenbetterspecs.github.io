---
title: Home
layout: home
---

<article>
  <h1>
      What is it?
  </h1>

  <p>Event Better Specs is an <i>opinionated</i> set of best practices to support the creation of tests that are easy to read and maintain.</p>

  <p>It focus on the <a href="https://www.ruby-lang.org/en/">Ruby</a> testing framework <a href="https://rspec.info/">RSpec</a>, but some of it could potentially be applied to other frameworks (like <a href="https://github.com/sus-rb/sus">sus</a>) and languages (like <a href="https://crystal-lang.org/reference/1.13/guides/testing.html">Crystal</a>).</p>

  <h2>
      Guiding principles
  </h2>

  <ul>
    <li>
      tests must be <a href="https://thoughtbot.com/blog/the-self-contained-test">self-contained</a>, not DRY
    </li>
    <li>
      tests should follow the <a href="https://automationpanda.com/2020/07/07/arrange-act-assert-a-pattern-for-writing-good-tests/">Arrange-Act-Assert</a> pattern
    </li>
  </ul>
</article>

<article>
  <h2 id="describe">
    <a href="#describe">
      Describe what you are testing
    </a>
  </h2>

  <p>Be clear about what method you are describing. For instance, use the Ruby documentation convention of <code>.</code> when referring to a class method's name and <code>#</code> when referring to an instance method's name.</p>

  <div class="bad">
{% highlight ruby %}
describe 'the authenticate method for User' do
describe 'if the user is an admin' do
{% endhighlight %}
  </div>

  <div class="good">
{% highlight ruby %}
describe '.authenticate' do
describe '#admin?' do
{% endhighlight %}
  </div>
</article>


<article>
  <h2 id="use-contexts">
    <a href="#use-contexts">
      Use contexts
    </a>
  </h2>

  <p>Contexts are a powerful way to make your tests clear and well organized (they keep tests easy to read). They should start with <code>when</code>.</p>

  <div class="bad">
{% highlight ruby %}
it 'has 200 status code if logged in' do
  expect(response.code).to eq('200')
end

describe 'it returns 401 status code if not logged in' do
  expect(response.code).to eq('401')
end
{% endhighlight %}
  </div>

  <div class="good">
{% highlight ruby %}
context 'when logged in' do
  expect(response.code).to eq('200')
end

context 'when logged out' do
  it 'returns 401 status code' do
    expect(response.code).to eq('401')
  end
end
{% endhighlight %}
  </div>
</article>

<article>
  <h2 id="short-description">
    <a href="#short-description">
      Short description 
    </a>
  </h2>

  <p>A spec description should never be longer than 40 characters. If this happens you should split it using a context.</p>

  <div class="bad">
{% highlight ruby %}
it 'has 422 status code if an unexpected params will be added' do
{% endhighlight %}
  </div>

  <div class="good">
{% highlight ruby %}
context 'when not valid' do
  it { is_expected.to respond_with 422 }
end
{% endhighlight %}
  </div>

  <p>
    In the example we removed the description related to the status code, which has been replaced by the 
    expectation <code>is_expected</code>. If you run this test typing rspec filename you will obtain a readable 
    output.
  </p>

  <div class="output">
{% highlight ruby %}
when not valid
  it should respond with 422
{% endhighlight %}
  </div>
</article>

<article>
  <h2 id="single-expectation">
    <a href="#single-expectation">
      Single expectation 
    </a>
  </h2>

  <p>
    The 'one expectation' tip is more broadly expressed as 'each test should make only one assertion'. 
    This helps you on finding possible errors, going directly to the failing test, and to make your code 
    readable. In isolated unit specs, you want each example to specify one (and only one) behavior. 
    Multiple expectations in the same example are a signal that you may be specifying multiple behaviors.
  </p>

  <div class="good">
{% highlight ruby %}
it { is_expected.to respond_with_content_type(:json) }
it { is_expected.to assign_to(:resource) }
{% endhighlight %}
  </div>

  <p>
    Anyway, in tests that are not isolated (e.g. ones that integrate with a DB, an external webservice, or 
    end-to-end-tests), you take a massive performance hit to do the same setup over and over again, 
    just to set a different expectation in each test. In these sorts of slower tests, I think it's fine to 
    specify more than one isolated behavior.
  </p>

  <div class="good">
{% highlight ruby %}
it 'creates a resource' do
  expect(response).to respond_with_content_type(:json)
  expect(response).to assign_to(:resource)
end
{% endhighlight %}
  </div>
</article>

<article>
  <h2 id="all-possible-cases">
    <a href="#all-possible-cases">
      All possible cases
    </a>
  </h2>

  <p>Testing is a good practice, but if you do not test the edge cases, it will not be useful. Test valid, edge and invalid case. For example, consider the following action..</p>

  <p class="note alert">If you have way too many cases to test, it might be an indication your subject class is doing too much and must be break down into other classes.</p>

  <div class="example">
{% highlight ruby %}
before_action :authenticate_user!
before_action :find_product

def destroy
  @product.destroy
  redirect_to products_path
end
{% endhighlight %}
  </div>

  <div class="bad">
{% highlight ruby %}
describe "#destroy" do
  context "when product exists" do
    it "deletes the product" do
    end
  end
end
{% endhighlight %}
  </div>

  <div class="good">
{% highlight ruby %}
describe "#destroy" do
  context "when product exists" do
    it "deletes the product" do
    end
  end

  context "when product does not exist" do
    it "raises 404" do
    end
  end

  context "when user is not authenticated" do
    it "raises 404" do
    end
  end
end
{% endhighlight %}
  </div>
</article>


<article>
  <h2 id="expect-vs-should">
    <a href="#expect-vs-should">
      Expect vs should syntax
    </a>
  </h2>

  <p>Always use <code>expect</code> instead of <code>should</code>.</p>

  <div class="bad">
{% highlight ruby %}
it 'creates a resource' do
  response.code.should eq('200')
end"
{% endhighlight %}
  </div>

  <div class="good">
{% highlight ruby %}
it 'creates a resource' do
  expect(response.code).to eq('200')
end
{% endhighlight %}
  </div>
</article>


<article>
  <h2 id="lets-not">
    <a href="#lets-not">
      Let's not
    </a>
  </h2>

  <p>Do not use <code>let</code> / <code>let!</code>. These tend to turn your tests very complicated over time as one needs to look up variables defined then apply deltas to figure their current state. Read more <a href="https://thoughtbot.com/blog/lets-not">here</a>.</p>

  <p class="note info">Tests are not supposed to be DRY, but easy to read and maintain.</p>

  <div class="bad">
{% highlight ruby %}

describe '#name' do
  let(:user) { create(:user, fist_name: 'Ayrton', last_name: 'Senna') }

  context 'when first name and last name are present' do
    it 'returns the full name' do
      expect(user.name).to eq('Ayrton Senna')
    end
  end

  context 'when last name is not present' do
    it 'returns the first name' do
      user.last_name = nil
      expect(user.name).to eq('Ayrton')
    end
  end
end
{% endhighlight %}
  </div>

  <div class="good">
{% highlight ruby %}
describe '#name' do
  context 'when first name and last name are present' do
    it 'returns the full name' do
      user = create(:user, fist_name: 'Ayrton', last_name: 'Senna')
      expect(user.name).to eq('Ayrton Senna')
    end
  end

  context 'when last name is not present' do
    it 'returns the first name' do
      user = create(:user, fist_name: 'Ayrton', last_name: nil)
      expect(user.name).to eq('Ayrton')
    end
  end
end
{% endhighlight %}
  </div>
</article>



<article>
  <h2 id="avoid-hooks">
    <a href="#avoid-hooks">
      Avoid hooks
    </a>
  </h2>

  <p>Avoid hooks whenever possible since they tend to make your tests complicated over time.</p>

  <div class="bad">
{% highlight ruby %}
describe '#index' do
  context 'when user is authenticated' do
    before do
      @user = create(:user)
      sign_in @user
    end

    context 'when user is admin' do
      it 'returns 200' do
      end
    end

    context 'when user is not admin' do
      it 'returns 401' do
      end
    end
  end
end
{% endhighlight %}
  </div>

  <div class="good">
{% highlight ruby %}
describe '#index' do
  context 'when user is authenticated' do
    context 'when user is admin' do
      it 'returns 200' do
        user = create(:user)
        sign_in user
      end
    end

    context 'when user is not admin' do
      it 'returns 401' do
        user = create(:user)
        sign_in user
      end
    end
  end
end
{% endhighlight %}
  </div>
</article>


<article>
  <h2 id="mock-external-dependencies">
    <a href="#mock-external-dependencies">
      Mock external dependencies
    </a>
  </h2>

  <p>Mock external dependencies to your test subject. By external dependencies I mean code that's not the main responsibility of the subject under test.</p>

  <div class="example">
{% highlight ruby %}
def github_stars(repository_id)
  stars = Github.fetch_repository_stars(repository_id)
  "Stars: #{stars}"
end
{% endhighlight %}
  </div>

  <div class="bad">
{% highlight ruby %}
describe '#github_stars' do
  it 'displays the number of stars' do
    expect(subject.github_stars(1)).to eq('Stars: 10')
  end
end
{% endhighlight %}
  </div>

  <div class="good">
{% highlight ruby %}
describe '#github_stars' do
  it 'displays the number of stars' do
    expect(Github).to receive(:fetch_repository_stars).with(1).and_return(10)
    expect(subject.github_stars(1)).to eq('Stars: 10')
  end
end
{% endhighlight %}
  </div>

  <p>
    Unless you intentionally want to test the underlying dependencies. This type of test must be limited to very few cases though otherwise it will make your test suite slow and hard to maintain.
  </p>

  <div class="example">
{% highlight ruby %}
def process(payload)
  UserCreator.new(payload).create
  ProductCreator.new(payload).create
end
{% endhighlight %}
  </div>

  <div class="good">
{% highlight ruby %}
describe '#process' do
  it 'creates a user and a product' do
    payload = { user: { name: 'John' }, product: { name: 'Book' } }

    subject.process(payload)

    expect(User.count).to eq(1)
    expect(Product.count).to eq(1)
  end
end
{% endhighlight %}
  </div>
</article>



<article>
  <h2 id="stub-http-requests">
    <a href="#stub-http-requests">
      Stub HTTP requests
    </a>
  </h2>

  <p>Sometimes you need to access external services. In these cases you can't rely on the real service but you should stub it with solutions like <a href="https://github.com/bblimke/webmock" target="_blank">webmock</a> or <a href="https://github.com/vcr/vcr" target="_blank">VCR</a>.</p>

  <div class="example">
{% highlight ruby %}
def request
  uri = URI.parse("http://www.example.com/")
  request = Net::HTTP::Post.new(uri.path)
  request['Content-Length'] = 3

  Net::HTTP.start(uri.host, uri.port) do |http|
    http.request(request, "abc")
  end
end
{% endhighlight %}
  </div>

  <div class="bad">
{% highlight ruby %}
describe '#request' do
  response = subject.request

  expect(response.code).to eq('200')
end
{% endhighlight %}
  </div>

  <div class="good">
{% highlight ruby %}
describe '#request' do
  stub_request(:post, "www.example.com").with(body: "abc", headers: { 'Content-Length' => 3 })

  response = subject.request

  expect(response.code).to eq('200')
end
{% endhighlight %}
  </div>
</article>



<article>
  <h2 id="create-only-the-data-you-need">
    <a href="#create-only-the-data-you-need">
      Create only the data you need
    </a>
  </h2>

  <p>Create only the data you need for each test. Having more data than necessary might make your suite slow.</p>

  <div class="bad">
{% highlight ruby %}
describe '#featured_product' do
  it 'returns the featured product' do
    create_list(:product, 5)
    product_featured = create(:product, featured: true)

    expect(subject.featured_product).to eq(product_featured)
  end
end
{% endhighlight %}
  </div>

  <div class="good">
{% highlight ruby %}
describe '#featured_product' do
  it 'returns the featured product' do
    product_non_featured = create(:product, featured: false)
    product_featured = create(:product, featured: true)

    expect(subject.featured_product).to eq(product_featured)
  end
end
{% endhighlight %}
  </div>
</article>


<article>
  <h2 id="dont-use-shared-examples">
    <a href="#dont-use-shared-examples">
      Don't use shared examples
    </a>
  </h2>

  <p><a href="https://rspec.info/features/3-12/rspec-core/example-groups/shared-examples/">Shared examples</a> is a feature that allow us to not repeat code, but tests are not real code, so introducing it increases the complexity of your suite</a>.</p>

  <div class="bad">
{% highlight ruby %}
shared_examples 'a normal dog' do
  it { is_expected.to be_able_to_jump }
  it { is_expected.to be_able_to_bark }
end

RSpec.describe Dog do
  subject { described_class.new(able_to_jump?: true, able_to_bark?: true) }
  it_behaves_like 'a normal dog'
end
{% endhighlight %}
  </div>

  <div class="good">
{% highlight ruby %}
RSpec.describe Dog do
  it "barks and jumps" do
    subject = described_class.new(able_to_jump?: true, able_to_bark?: true)

    expect(subject).to be_able_to_jump
    expect(subject).to be_able_to_bark
  end
end
{% endhighlight %}
  </div>
</article>